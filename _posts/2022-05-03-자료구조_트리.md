---
title: "자료구조 트리 "
header:
  teaser: /assets/images/1.jpg
  og_image: /assets/images/1.jpg
show_date: true
layout: single
classes:
  - landing
  - dark-theme
categories:
  - 자료구조
  - 트리
---   

# 트리(TREE)

트리는 부모-자식 관계의 노드들로 이루어진다.

- 응용분야
    - 계층적인 조직 표현
    - 컴퓨터 디스크의 디렉토리 구조
    - 인공지능에서의 결정트리(decision tree)

- 용어
    - 노드(node) : 트리의 구성요소
    - 루트(root) : 부모가 없는 노드
    - 서브트리(subtree) : 하나의 노드와 그 노드들의 자손들로 이루어진 트리
    - 단말노드(terminal node): 자식이 없는 노드
    - 비단말노드 : 적어도 하나의 자식을 가지는 노드
    - 레벨(level) : 트리의 각층의 번호
    - 높이(height) : 트리의 최대 레벨
    - 차수(degree) : 노드가 가지고 있는 자식 노드의 개수

- 종류
    - 이진 트리
    - 일반 트리

### 이진트리
- 이진 트리(binary tree) : 모든 노드가 2개의 서브 트리를 가지고 있는 트리
    - 서브트리는 공집합일수 있다.
- 이진트리의 노드에는 **최대 2개** 까지의 자식 노드가 존재
- 모든 노드의 차수가 2 이하가 된다 -> 구현하기 편리
- 이진 트리에는 서브 트리간의 순서가 존재

### 이진 트리 검증
- 이진 트리는 공집합이거나
- 루트와 왼쪽 서브 트리, 오른쪽 서브 트리로 구성된 노드들의 유한집합으로 정의된다. 이진 트리의 서브 트리들은 모두 이진 트리어야 한다.

### 이진 트리의 성질
- 노드의 개수가 n개라면 간선(link)의 개수는 n-1 
- 높이가 h인 이진트리의 경우, 최소 h개의 노드를 가지며 최대 2^h-1개의 노드를 가진다.
- n개의 노드를 가지는 이진트리의 높이
    - 최대 n
    - 최소 log2(n+1)
### 이진 트리의 분류
- 포화 이진트리(Full binary tree)
    - 용어 그대로 트리의 각 레벨에 노드가 꽉 차있는 이진트리를 의미한다.
    - 완전 이진 트리도 포함된다.
- 완전 이진 트리(Complete binary tree)
    - 레벨 1부터 k-1까지는 노드가 모두 채워져 있고 마지막 레벨 k에서는 왼쪽 부터 오른쪽으로 노드가 순서대로 채워져 있는 이진트리
- 기타 이진 트리

### 이진트리의 표현
- 배열을 이용
    - 배열표현법 : 모든 이진 트리를 포화 이진 트리라고 가정하고 각 노드에 번호를 붙여서 그 번호를 배열의 인덱스로 삼아 노드의 데이터를 배열에 저장하는 방법. 경사 이진트리처럼 밸런스가 맞지않는 이진트리를 표현하는 경우 효율적이지 못하다.
    - 부모와 자식 인덱스 관계
        - 노드 i의 부모 노드 인덱스 -> i/2
        - 노드 i의 왼쪽 자식 노드 인덱스 -> 2*i
        - 노드 i의 오른쪽 자식 노드 인덱스 -> 2*i+1 (left+1)
- 포인터를 이용
    - 링크 표현법 : 포인터를 이용하여 부모노드가 자식노드를 가리키게 하는 방법
    - 1개의 데이터필드와 2개의 링크필드(left, right) 필요


### 이진 트리의 순회
- 순회(traversal) : 트리의 노드들을 체계적으로 방문하는 것
- 3가지의 기본적인 순회방법  
 루트를 기준으로 이해하면 편한다.
 무조건 왼쪽이 먼저이다 RL(X) LR(O)
    - 전위순회(VLR)
        - 자손노드보다 루트노드를 먼저 방문
        - 루트가 가장먼저 방문 L->R
    - 중위순회(LVR)
        - 왼쪽 자손, 루트 ,오른쪽 자손 순으로 방문한다.
        - 루트가 중간 L->V(중간)->R
    - 후위순회(LRV)
        - 루트노드보다 자손을 먼저 방문한다.
        - L->R 루트가 제일 마지막 V

### 이진탐색트리
- 탐색작업을 효율적으로 하기 위한 자료구조
- key(왼쪽서브트리)<=key(루트노드)<=key(오른쪽서브트리)
    - 일반적으로 같은 중복된 key값을 허용하지는 않는다.
- 이진탐색을 중위순회하면 오름차순으로 정렬된 값을 얻을 수 있다.

### 이진탐색연산
- 비교한 결과가 같으면 탐색이 성공적으로 끝남
- 비교한 결과가, 주어진 키 값이 루트 노드의 키값보다 작으면 탐색으 루트 노드의 왼쪽 자식을 기준으로 다시 시작.
- 비교한 결과가, 주어진 키 값이 루트 노드의 키값보다 크면 탐색은 이 루트 노드의 오른쪽 자식을 기준으로 다시 시작.
### 찾아야하는 값이 루트보다 작으면 왼쪽 크면 오른쪽으로 재탐색

### 구현

- TREE 구조체 생성
- TREE INSERT 함수
- 전위 순회 구현
- 중위 순회 구현 (내림차순 정렬)
- 후위 순회 구현

```c++
#include <stdio.h>
#include <stdlib.h>

typedef int element;

typedef struct TreeNode{
    element key;
    struct TreeNode * left;
    struct TreeNode * right;
}TreeNode;

TreeNode * insertNode(TreeNode* Root, element key){
    if(Root == NULL){ // 루트노드가 비어있다면 새로운 노드 생성
        TreeNode * node = (TreeNode*)malloc(sizeof(TreeNode));
        node->key = key;
        node->left = NULL; //자식이 없는 단말노드
        node->right = NULL; //자식이 없는 단말노드
        return node; // 만들어진 노드의 주소를 반환
    } 
    // 루트가 NULL이 아닌경우 노드가 들어갈 위치를 찾아야 함(재귀적으로)

    if(key < Root->key) //들어올 key값과 root의 key를 비교 같은경우는 아무것도 하지않는다.
        Root->left = insertNode(Root->left,key);
    else if(key > Root->key)
        Root->right = insertNode(Root->right, key);
    return Root;
}

void preOrder(TreeNode * Root){// 전위 순회 V->L->R
    if(Root){
        printf("[%d] ", Root->key);
        preOrder(Root->left);
        preOrder(Root->right);
    }
}

void inOrder(TreeNode * Root){ //중위 순회 L->V->R 내림차순 정렬이기도 하다.
    if(Root)
    {
        inOrder(Root->left);
        printf("[%d] ", Root->key);
        inOrder(Root->right);
    }

}

void postOrder(TreeNode * Root){ //후위 순회 L->R->V
    if(Root){
        postOrder(Root->left);
        postOrder(Root->right);
        printf("[%d] ", Root->key);
    }
}




int main(){

    TreeNode * Root = NULL;
    Root = insertNode(Root, 35); //날라오는 주소를 받아줘야한다.
    Root = insertNode(Root, 68);
    Root = insertNode(Root, 99);
    Root = insertNode(Root, 18);
    Root = insertNode(Root, 7);
    Root = insertNode(Root, 3);
    Root = insertNode(Root, 12);
    Root = insertNode(Root, 26);
    Root = insertNode(Root, 22);
    Root = insertNode(Root, 30);
    preOrder(Root);
    printf("\n");
    inOrder(Root);
    printf("\n");
    postOrder(Root);
    printf("\n");
    return 0;
}
```


# 우선순위 큐
우선순위 큐(priority queue): 우선순위를 가진 항목들을 저장하는 큐  
FIFO순서가 아니라 우선 순위가 높은 데이터가 먼저 나가게 된다.
### 우선순위 큐를 구현하는 방법

- 배열을 이용한 우선순위 큐
- 연결리스트를 이용한 우선순위 큐
- 힙(heep)을 이용한 우선순위 큐

<img width="211" alt="스크린샷 2022-05-10 오전 10 49 14" src="https://user-images.githubusercontent.com/79856225/167526404-05c0c6f6-111b-4a5c-bb66-bf8e02dfeeaf.png">

### 히프(Heap)란?
- 노드의 키들이 다음 식을 만족하는 **완전이진트리**
- Key(부모노드) >= Key(자식노드) 

### 히프의 복잡도 분석

- 삽입 연산에서 최악의 경우, 루트 노드까지 올라가야 하므로 트리의 높이에 해당하는 비교 연산 및 이동 연산이 필요함 O(logn)

- 삭제도 최악의 경우, 가장 아래 레벨까지 내려가야 하므로 역시 트리의 높이 만큼의 시간이 걸린다. -> O(logn)


### 히프(Heap)의 종류
- Max Heap(최대힙)
    - 부모 노드의 키값이 자식 노드의 키값보다 크거나 같은 완전 이진 트리
    - 부모는 무조건 자식보다 크거나 같아야 한다
- Min Heap(최소힙)
    - 부모 노드의 키값이 자식 노드의 키값보다 작거나 같은 완전 이진 트리
    - 부모는 무조건 자식보다 작거나 같아야 한다
#### 이진탐색트리와 다르게 히프(Heap)는 중복된 키값을 허용한다.

### 히프(Heap)의 높이
- N개의 노드를 가지고 있는 히프의 높이는 O(logn)
    -   히프(Heap)는 완전이진트리
    - 마지막 레벨 h을 제외하고는 각 레벨 i에 2^(i-1)개의 노드 존재

### 히프(Heap) 구현방법
- 히프(Heap)는 배열을 이용하여 구현
    - 완전이진트리이므로 각 노드에 번호를 붙일 수 있다.
    - 이 번호를 배열의 인덱스라고 생각
- 부모노드와 자식노드를 찾기가 쉽다.
    - 왼쪽 자식의 인덱스 = 부모의 인덱스 * 2
    - 오른쪽 자식의 인덱스 = 부모의 인덱스 *2+1
    - 부모의 인덱스 = 자식의 인덱스 /2

### 힙(Heap) 정렬

- 힙(Heap))을 이용하면 정렬 가능

- 먼저 정렬해야 할 N개의 요소들을 최대 힙(Heap)에 삽입

- 한번에 하나씩 요소를 힙(Heap)에서 삭제하여 저장하면 된다.

- 삭제되는 요소들은 값이 증가되는 순서(최소힙(Min_Heap)의 경우)

- 하나의 요소를 힙에 삽입하거나 삭제할 때 시간이 O(logn)만큼 소요되고 요소의 개수가 N개이므로 
전체적으로 O(lnogn)시간이 걸린다. (빠른편)

- 힙(Heap) 정렬이 최대로 유용한 경우는 전체 자료를 정렬하는 것이 아니라 가장 큰 값 몇 개만 필요할 때이다.

- 이렇게 힙(Heap)을 사용하는 정렬 알고리즘을 <u>**힙정렬(Heap Sort)**</u>이라고 한다.

### 허프만 코드

- 이진 트리는 각 글자의 빈도가 알려져 있는 메시지의 **내용을 압축**하는데 사용될 수 있다.

- 이런 종류의 이진트리를 허프만 코딩 트리라고 부른다.(빈도수 분석)

1. 알파벳의 빈도수를 나열함 

2. 전체 알파벳의 개수 * 8byte

3. 빈도수가 제일 낮은알파벳부터 묶는다.(2개씩)

4. 다음 빈도수가 낮은 알파벳을 묶을때 그 전에 묶은것도 같이 묶는다.

5. 위 과정을 반복해서 이진트리를 만든다. 

6. 루트 1 왼쪽 0 오른쪽 1 

7. 빈도수가 낮으면 왼쪽 빈도수가 높으면 오른쪽



```c++
#include <stdio.h>
#include <stdlib.h>
#define N 100

typedef struct{
    int stack[N];
    int top;
}StackType;

void initStack(StackType* S){
    S->top = -1;
}


int isEmpty(StackType* S){
    return S->top == -1;
}


int isFull(StackType* S){
    return S->top == N - 1;
}


void push(StackType* S, int e){
    if(isFull(S))
        printf("Full\n");
    else
    {
        S->top++;
        S->stack[S->top] = e;
    }
}


int pop(StackType* S){
    if(isEmpty(S))
    {
        printf("Empty\n");
        return -1;
    }
    int elem = S->stack[S->top];
    S->top--;
    return elem;
}
///////////////////////// STACK //////////////////////

typedef struct 
{
    int heap[N];
    int heapSize;
}HeapType;

void init(HeapType* H){
    H->heapSize = 0;
}

void UpHeap(HeapType *H){
    int i = H->heapSize; // 힙의 크기를 임시 저장 
    int key = H->heap[i]; //

    while((i!=1) && (key > H->heap[i/2])){
        H->heap[i] = H->heap[i/2]; //위치를 바꾸고
        i = i/2; // 포인트를 부모노드로 
    } //루트가 아니고 부모노드보다 더 크다면 반복 지속
    H->heap[i] = key; // 최대 힙에 맞게 키값 삽입
}

void DownHeap(HeapType *H){
    int item = H->heap[1]; //루트로 올라간 Key를 저장
    int parent = 1; 
    int child = 2; // 왼쪽으로만 내려가는 화살표

    while( child <= H->heapSize){ //트리의 범위 안에서
        if((child< H->heapSize )&&(H->heap[child+1] > H->heap[child])){//오른쪽 형제가 있는지 확인 후 화살표가 오른쪽으로
            child ++;
        }
        if(item >= H->heap[child]){ //현재 아이템값이 더 큰 경우 해야할 일 없음
            break; 
        }
        H->heap[parent] = H->heap[child];
        parent = child;
        child = child * 2;
    } //while
    H->heap[parent] = item;
}

int removeItem(HeapType *H){
    int item = H->heap[1]; // 루트값을 저장
    H->heap[1] = H->heap[H->heapSize]; // 제일 밑 노드를 루트노드로 올린다.
    H->heapSize --; // Heap사이즈 한개 감소
    DownHeap(H);
    return item;
}

void insertItem(HeapType *H, int key){
    H->heapSize ++; // 크기를 하나 증가시킴
    H->heap[H->heapSize] = key; // 증가시킨 곳에다가 Key값을 삽입
    UpHeap(H); //최대힙을 만드는 과정
}

void heapSortV1(HeapType *H){ //힙 정렬 정렬을 위해 필요한 배열을 추가적으로 생산하는 방법
    int n = H->heapSize; // 힙 사이즈를 미리 저장해둬야 함
    int A[n]; // 정렬을 위해 필요한 공간

    for(int i=n-1; i>=0; i--) // n만큼 반복
        A[i] = removeItem(H); //삭제 연산은 logn 
        // 따라서 힙정렬은  O(n*logn)
    
    for(int i=0; i<n; i++)
        printf("(%d)", A[i]);
    printf("\n");
} 

void heapSortV2(HeapType *H){
    int n = H->heapSize;

    for(int i=1; i<=n; i++){ //직접적으로 넣어줄 배열이 없음
        int key = removeItem(H); // 리턴받은 루트값을 저장 -> 힙 사이즈가 하나씩 감소함
        H->heap[H->heapSize+1] = key; 
    }

    for(int i=1; i<=n; i++)
       printf("(%d)", H->heap[i]);
    printf("\n");
}

void binaryExpansion(StackType *S , int i){
    while(i>=2){
        push(S,i%2);
        i = i/2;
    }
    push(S,1); //루트는 1
}

void findLastNode(HeapType *H){
    StackType S;
    initStack(&S);
    int value;
    int nodeNum = 1;
    binaryExpansion(&S, H->heapSize); //노드의 마지막 번호를 이진수로 만들어서 스택에 저장하는 함수
    pop(&S); //루트를 버림

    while(!isEmpty(&S)){
        int bit = pop(&S); // 한비트씩 빼냄
        printf("%d", bit); //동작하고는 상관없는 확인용 출력문

        if(bit == 0){
            nodeNum = nodeNum * 2 ; //왼쪽으로 감
            value = H->heap[nodeNum];
        }
        else{
           nodeNum = nodeNum * 2+1 ; //오른쪽으로 감
           value = H->heap[nodeNum];
        }
    }

    printf("\nLast Node : %d\n", value);
    
}

void printHeap(HeapType *H){
    for(int i=1; i<=H->heapSize; i++)
        printf("(%d)", H->heap[i]);
    printf("\n");
}
//////////////////////////// HEAP //////////////////////////////


int main(){
    HeapType H;
    init(&H);

    insertItem(&H, 9); insertItem(&H, 7); insertItem(&H, 6);
    insertItem(&H, 5); insertItem(&H, 4); insertItem(&H, 3);
    insertItem(&H, 2); insertItem(&H, 2); insertItem(&H, 1);
    insertItem(&H, 3); printHeap(&H); getchar();

    // insertItem(&H, 8); printHeap(&H);
    removeItem(&H); printHeap(&H);
    getchar();
    // heapSortV1(&H);
    // getchar();
    heapSortV2(&H);
    getchar();

    findLastNode(&H);

    return 0;
}
```


