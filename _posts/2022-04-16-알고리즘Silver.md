---
title: "Java 또는 C++로 푸는 백준 실버"
header:
  teaser: /assets/images/1.jpg
  og_image: /assets/images/1.jpg
show_date: true
layout: single
classes:
  - landing
  - dark-theme
categories:
  - 알고리즘
  - silver
---      

* 그룹단어체커  

풀이 : 알파벳배열을 만들고 특정 단어가 나오면 알파벳 배열의 1을 넣고 연속인지 체크  
만약 배열의 1이 있으면서 체크랑도 다르다면 그건 중복된 숫자가 나왔으면서 연속도 아니라는  의미! 따라서 카운트 1 올리고 break
모든 반복 이후   
총 반복횟수 - 그룹단어카운트 =  정답!
```c++

#include <iostream>
#include <algorithm>
#include <string>

using namespace std;
int main(){
    cin.tie(NULL);
    ios_base::sync_with_stdio(false);

    int testCase;
    int check = 0;
    int cnt = 0;
    
    cin >>testCase;
    int temp =testCase;
    while(testCase--){
        int alpha[27] = {0};
        string str ;
        cin >> str;
        int len = str.length(); 
        check = 0;
        for(int i=0; i<len; i++){ 
            if(alpha[str[i]-97]==0){   
                 alpha[str[i]-97] = 1;
                 check = str[i];
            }
            if(check == str[i])
                continue;       
            else{
                cnt++;
                break;
            }
        }
    }
    int sum = temp - cnt ;
    cout << sum <<endl;

    return 0;
}

```

#### 백준 1425 소트인사이드    
배열을 정렬하는 것은 쉽다. 수가 주어지면, 그 수의 각 자리수를 내림차순으로 정렬해보자.
#### 입력   
#### 첫째 줄에 정렬하려고 하는 수 N이 주어진다. N은 1,000,000,000보다 작거나 같은 자연수이다.  
#### 출력  
#### 첫째 줄에 자리수를 내림차순으로 정렬한 수를 출력한다.

#### 풀이 : 이 문제는 벡터를 이용하면 간단하게 해결이 가능하다. 먼저 입력받은 정수의 각 자리수를 벡터의 담아 준 후 벡터를 내림차순으로 정렬해주면 정답 !
```c++

#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main(){
    int N;
    cin >> N;
    vector<int>ans;
    while(N!=0){
        ans.push_back(N%10);
        N = N/10;
    }
    sort(ans.rbegin(), ans.rend());
    vector<int>:: iterator it = ans.begin();

    for(; it!=ans.end(); it++){
        cout << *it;
    }
    return 0;
}

```