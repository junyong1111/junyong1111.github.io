---
title: "알고리즘_브론즈1"
header:
  - overlay_image: /assets/images/algo.jpg
show_date: true
layout: splash
classes:
  - landing
  - dark-theme
categories:
  - 알고리즘
---

###### 1.백준(1546) 평균
###### 세준이는 기말고사를 망쳤다. 세준이는 점수를 조작해서 집에 가져가기로 했다. 일단 세준이는 자기 점수 중에 최댓값을 골랐다. 이 값을 M이라고 한다. 그리고 나서 모든 점수를 점수/M*100으로 고쳤다. 예를 들어,   세준이의 최고점이 70이고, 수학점수가 50이었으면 수학점수는 50/70*100이 되어 71.43점이 된다. 세준이의 성적을 위의 방법대로 새로 계산했을 때, 새로운 평균을 구하는 프로그램을 작성하시오.
###### -입력
###### 첫째 줄에 시험 본 과목의 개수 N이 주어진다. 이 값은 1000보다 작거나 같다. 둘째 줄에 세준이의 현재 성적이 주어진다. 이 값은 100보다 작거나 같은 음이 아닌 정수이고, 적어도 하나의 값은 0보다 크다.
###### -출력 
###### 첫째 줄에 새로운 평균을 출력한다. 실제 정답과 출력값의 절대오차 또는 상대오차가 10-2 이하이면 정답이다.

```c++
#include <stdio.h>
#include <stdlib.h>

int main(){
    int N ;
    scanf("%d", &N);
    float arr[N];
    int max = 0;
    float mean = 0;
    for(int i =0; i<N; i++){
        scanf("%f", &arr[i]);
    }
    max = arr[0];
    for(int i =1 ;i <N; i++){
        if(max <= arr[i]){max = arr[i];}
    }
    for(int i=0; i<N; i++){
        arr[i] = arr[i]/max*100;
        mean += arr[i];
    }
    mean = mean / N;
    printf("%.2f", mean);
    return 0;
}
```
###### 2.백준(4344) 평균은 넘겠지
###### 대학생 새내기들의 90%는 자신이 반에서 평균은 넘는다고 생각한다. 당신은 그들에게 슬픈 진실을 알려줘야 한다.
###### -입력
###### 첫째 줄에는 테스트 케이스의 개수 C가 주어진다. 둘째 줄부터 각 테스트 케이스마다 학생의 수 N(1 ≤ N ≤ 1000, N은 정수)이 첫 수로 주어지고, 이어서 N명의 점수가 주어진다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.
###### -출력 
###### 각 케이스마다 한 줄씩 평균을 넘는 학생들의 비율을 반올림하여 소수점 셋째 자리까지 출력한다.

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void){
    int testcase ;
    float mean = 0;
    int cnt = 0;
    scanf("%d", &testcase);

    for(int i=0; i<testcase; i++){
        int student = 0;
        cnt = 0;
        mean = 0;
        scanf("%d", &student);
        int arr[student];
        for(int j=0; j<student; j++){
            scanf("%d", &arr[j]);
            mean += arr[j];
        }
        mean = mean/student;
        for(int j=0; j<student; j++){
            if(mean <arr[j])
                cnt ++;      
        } // for_jj
        mean = (float)cnt / student;
        mean = mean * 100;
        printf("%.3f%%\n", mean);
    } //for_i

    return 0;
}
```
###### 3.백준(1157) 단어 공부
###### 알파벳 대소문자로 된 단어가 주어지면, 이 단어에서 가장 많이 사용된 알파벳이 무엇인지 알아내는 프로그램을 작성하시오. 단, 대문자와 소문자를 구분하지 않는다.
###### -입력
###### 첫째 줄에 알파벳 대소문자로 이루어진 단어가 주어진다. 주어지는 단어의 길이는 1,000,000을 넘지 않는다.
###### -출력 
###### 첫째 줄에 이 단어에서 가장 많이 사용된 알파벳을 대문자로 출력한다. 단, 가장 많이 사용된 알파벳이 여러 개 존재하는 경우에는 ?를 출력한다.

```c++

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>
#define MAX_SIZE 1000000
int main(){
    int len = 0;
    char str[MAX_SIZE];
    int alpha[26] = {0};
    int temp = 0;
    int max = 0;
    char ans[1];
    int cnt = 0;
    
    scanf("%s", str);
    len = strlen(str);
    for(int i=0; i<len; i++)
        if (str[i] >= 65 && str[i] <= 90) { str[i] = str[i] + 32; } //대문자를 소문자로
    for(int i=0; i<len; i++){
        temp = str[i]-97;
        alpha[temp]++;
    } // 각 알파벳이 나온 빈도 체크
    for(int i=0; i<26; i++){
        if(max <= alpha[i]) {
            max = alpha[i];
            ans[0] = i+97;
        } //가장 많이 나온 알파벳 체크
    }
    for(int i=0; i<26; i++){
        if(max == alpha[i]) {cnt++;}  // 최대가 중복이면 ?출력
    }
    if(cnt >1){ printf("?\n");}
    else{
        printf("%c\n", ans[0]-32);
    } //그게 아닐경우 대문자 출력
    return 0;
}

```


###### 4.백준(2750) 수 정렬하기
###### N개의 수가 주어졌을 때, 이를 오름차순으로 정렬하는 프로그램을 작성하시오.
###### -입력
###### 첫째 줄에 수의 개수 N(1 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 수 주어진다. 이 수는 절댓값이 1,000보다 작거나 같은 정수이다. 수는 중복되지 않는다.
###### -출력 
###### 첫째 줄부터 N개의 줄에 오름차순으로 정렬한 결과를 한 줄에 하나씩 출력한다.

```c++
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

void sort(int arr[], int N){
    int temp = 0;
    for(int i=0; i<N; i++){
       for(int j= i+1; j<N; j++){
           if(arr[i]>arr[j]){
               temp = arr[j];
               arr[j] = arr[i];
               arr[i] = temp;
           } //배열을 돌면서 맨 앞부터 비교하면서 스왑해주기
           else continue;
       }
    }//for_i
    for(int i=0; i<N; i++){
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main(void){
    int N;
    scanf("%d",&N);
    int arr[N];
    for(int i=0; i<N; i++){
        scanf("%d", &arr[i]);
    }
    sort(arr,N);
    return 0;
}
```

###### 5.백준(2740) 행렬 곱
###### N*M크기의 행렬 A와 M*K크기의 행렬 B가 주어졌을 때, 두 행렬을 곱하는 프로그램을 작성하시오.
###### -입력
###### 첫째 줄에 행렬 A의 크기 N 과 M이 주어진다. 둘째 줄부터 N개의 줄에 행렬 A의 원소 M개가 순서대로 주어진다. 그 다음 줄에는 행렬 B의 크기 M과 K가 주어진다. 이어서 M개의 줄에 행렬 B의 원소 K개가 차례대로 주어진다. N과 M, 그리고 K는 100보다 작거나 같고, 행렬의 원소는 절댓값이 100보다 작거나 같은 정수이다.
###### -출력 
###### 첫째 줄부터 N개의 줄에 행렬 A와 B를 곱한 행렬을 출력한다. 행렬의 각 원소는 공백으로 구분한다.



```c++

#include <stdio.h>
#include <stdlib.h>

int main(){
    int N,M,K;
    int sum = 0;
    scanf("%d %d",&N,&M);
    int matrix1[N][M];
    for(int i=0; i<N; i++){
        for(int j=0; j<M; j++){
            scanf("%d",&matrix1[i][j]);
        }
    } //A 행렬 입력
    scanf("%d %d",&M,&K);
    int matrix2[M][K];
    for(int i=0; i<M; i++){
        for(int j=0; j<K; j++){
            scanf("%d",&matrix2[i][j]);
        }
    } // B 행렬 입력
    int matrix3[N][K];

    for(int i=0; i<N; i++){ //A행렬의 행만큼
        for(int j=0; j<K; j++){ //B행렬의 열만큼
            for(int k=0; k<M; k++){ // A행렬의 열 == B행렬의 행 만큼
                sum += matrix1[i][k] * matrix2[k][j];
            }
            matrix3[i][j] = sum;
            sum = 0;
        }
    }
    
    for(int i=0; i<N; i++){
        for(int j=0; j<K; j++){
            printf("%d ",matrix3[i][j]);
        }
        printf("\n");
    }
    return 0;
}

```