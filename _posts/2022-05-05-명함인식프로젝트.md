---
title: "OpenCV를 이용하여 명함스캐너 만들기"
header:
  overlay_image: /assets/images/OpenCV_Logo_with_text.png
  teaser: /assets/images/OpenCV_Logo_with_text.png
show_date: true
layout: single
date : 2022-05-05
classes:
  - landing
  - dark-theme
toc: true
toc_sticky: true
categories:
  - 컴퓨터비전
  - OpenCV
---  

```
MAC 사용
brew install tesseract
pip install pytesseract
```

## Step1. 이미지 읽어와서 가장자리 탐색
### 1. 일반적인 경우
```python
from tkinter import Image
import cv2
from cv2 import imshow
import numpy as np

def Imgcontour():
    img = cv2.imread('img.jpg', cv2.IMREAD_COLOR)
    GRAY = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    edge = cv2.Canny(GRAY, 100,200)
    contours , hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    ### 이진화된 이미지만 넘겨줘야 함
    
    cv2.imshow("Edge", edge)
    cv2.drawContours(img, contours, -1, (0,255,0), 1)
    cv2.imshow("Contours", img)
    
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    

if __name__ == '__main__':
    Imgcontour()
```

### 2. 찍고자하는 명함 또는 문서가 구겨진 경우 도형을 근사화 하는 방법

```python
from tkinter import Image
import cv2
from cv2 import imshow
import numpy as np


def Imgcontour():
    img = cv2.imread('img.jpeg', cv2.IMREAD_COLOR)
    copy_img = img.copy()
    copy_img_1 = img.copy()
    GRAY = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    edge = cv2.Canny(GRAY, 100,200)
    contours , hierarchy = cv2.findContours(edge, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    Cnt = contours[0]
    
    cv2.drawContours(img, [Cnt],0 , (0,255,0), 2)
    cv2.drawContours(copy_img_1, contours[1],0 ,(0,255,0), 2)
    epsilon = 0.1 * cv2.arcLength(Cnt, True)
    ### contour의 둘레의 길이를 확인하고 , 폐곡선 여부 확인 후 근사정확도(10퍼센트) 작을 수록 원본과 비슷함
    approx = cv2.approxPolyDP(Cnt, epsilon, True)
    cv2.drawContours(copy_img, [approx],0 , (0,255,0), 2)
    
    cv2.imshow("edge", edge)
    cv2.imshow("img", img)
    cv2.imshow("copy_img", copy_img)
    cv2.imshow("copy_img_1", copy_img_1)
    
    cv2.waitKey(0)
    cv2.destroyAllWindows()
    

if __name__ == '__main__':
    Imgcontour()
```

## Step2. 탐색한 가장자리를 이용하여 투영변환
자동으로 좌표 구하는 방법을 찾아야 한다..

```
import cv2
from cv2 import warpPerspective
import numpy as np

def wrapPerspective():
    img = cv2.imread('ocr.jpeg')
    TL = [100,200]
    TR = [200,300]
    BL = [300,400]
    BR = [200,400]
    
    pts1 = np.float32( [TL, TR, BL, BR])
    
    w1 = abs(BL[0] - BR[0])
    w2 = abs(TR[0] - TL[0])
    h1 = abs(TR[0] - BR[0])
    h2 = abs(TL[0] - BL[0])
    
    min_w = min([w1,w2]) ## 최소 너비
    min_h = min([h1,h2]) ## 최소 높이
    
    pts2 = np.float32([[0,0], [min_w-1,0], 
                       [min_w-1, min_h-1], [0,min_h-1]])
    M = cv2.getPerspectiveTransform(pts1, pts2)
    result = warpPerspective(img, M, (int(min_w), int(min_h)))
    
    cv2.imshow("OG img", img)
    cv2.imshow("Result", result)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

if __name__ == '__main__':
    wrapPerspective()                                      
```

### Step3. 이진화를 이용하여 조명값 제거

