---
title: "알고리즘_브론즈2"
header:
  overlay_image: /assets/images/algorithm.png
show_date: true
layout: splash
classes:
  - landing
  - dark-theme
categories:
  - 알고리즘
---

###### 1. 백준(2562) 최댓값
###### 9개의 서로 다른 자연수가 주어질 때, 이들 중 최댓값을 찾고 그 최댓값이 몇 번째 수인지를 구하는 프로그램을 작성하시오.
###### 예를 들어, 서로 다른 9개의 자연수
######  3, 29, 38, 12, 57, 74, 40, 85, 61
######  이 주어지면, 이들 중 최댓값은 85이고, 이 값은 8번째 수이다.

###### -입력
###### 첫째 줄부터 아홉 번째 줄까지 한 줄에 하나의 자연수가 주어진다. 주어지는 자연수는 100 보다 작다.
###### -출력
###### 첫째 줄에 최댓값을 출력하고, 둘째 줄에 최댓값이 몇 번째 수인지를 출력한다.

``` c++
#include <stdio.h>
#include <stdlib.h>

int main(){
    int n = 9;
    int arr[n];
    int idx = 1;
    for(int i=0; i<n; i++){
        scanf("%d",&arr[i]);
    }
    int max = arr[0];
    idx = 1;
    for(int i=1; i<n; i++){
        if(max <= arr[i]){
            max = arr[i];
            idx = i+1;
        }
    }
    printf("%d\n", max);
    printf("%d\n", idx);

    return 0;
}
```

###### 2. 백준(10809) 알파벳 찾기
###### 알파벳 소문자로만 이루어진 단어 S가 주어진다. 각각의 알파벳에 대해서, 단어에 포함되어 있는 경우에는 처음 등장하는 위치를, 포함되어 있지 않은 경우에는 -1을 출력하는 프로그램을 작성하시오..
###### -입력
###### 첫째 줄에 단어 S가 주어진다. 단어의 길이는 100을 넘지 않으며, 알파벳 소문자로만 이루어져 있다.
###### -출력 
###### 각각의 알파벳에 대해서, a가 처음 등장하는 위치, b가 처음 등장하는 위치, ... z가 처음 등장하는 위치를 공백으로 구분해서 출력한다.만약, 어떤 알파벳이 단어에 포함되어 있지 않다면 -1을 출력한다. 단어의 첫 번째 글자는 0번째 위치이고, 두 번째 글자는 1번째 위치이다

```c++
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

int main(){
    char str[101];
    int alpha[26];
    int check = 0;
    for(int i=0; i<26; i++){
        alpha[i] = -1;
    }
    int i = 0;
    int temp = 0;
    scanf("%s", str);
    int len = strlen(str);
    while(len--){
        temp = str[i] - 97;
        if(alpha[temp] == -1){
            alpha[temp] =i;
            i++;
        } // 처음 나온 알파벳이면 idx 저장
        else{ //중복 처리
            i++;
            continue;
        }
    } //while
    for(int i=0; i<26; i++){
        printf("%d ", alpha[i]);
    }
    printf("\n");
    return 0;
}
```

##### 3.백준(1152) 단어의 개수
##### 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열에는 몇 개의 단어가 있을까? 이를 구하는 프로그램을 작성하시오. 단, 한 단어가 여러 번 등장하면 등장한 횟수만큼 모두 세어야 한다.
##### -입력
##### 첫 줄에 영어 대소문자와 공백으로 이루어진 문자열이 주어진다. 이 문자열의 길이는 1,000,000을 넘지 않는다. 단어는 공백 한 개로 구분되며, 공백이 연속해서 나오는 경우는 없다. 또한 문자열은 공백으로 시작하거나 끝날 수 있다.
##### -출력 
##### 첫째 줄에 단어의 개수를 출력한다.

```c++

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_SIZE 1000000

int main(void){
    int i, len;
    int cnt = 1;
    char str[MAX_SIZE]; 
    scanf("%[^\n]", str); 
    len = strlen(str);
    if(len == 1) { 
        if(str[0] == ' ') {
             printf("0\n"); 
             return 0; 
        } 
    } 
    for(i = 1; i < len-1; i++) { 
        if(str[i] == ' ') 
        cnt++; 
    } 
    printf("%d\n", cnt); 
    return 0; 
    }
```

###### 4.백준(8958) OX퀴즈
###### "OOXXOXXOOO"와 같은 OX퀴즈의 결과가 있다. O는 문제를 맞은 것이고, X는 문제를 틀린 것이다. 문제를 맞은 경우 그 문제의 점수는 그 문제까지 연속된 O의 개수가 된다. 예를 들어, 10번 문제의 점수는 3이 된다. "OOXXOXXOOO"의 점수는 1+2+0+0+1+0+0+1+2+3 = 10점이다. OX퀴즈의 결과가 주어졌을 때, 점수를 구하는 프로그램을 작성하시오.
###### -입력
###### 첫째 줄에 테스트 케이스의 개수가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 길이가 0보다 크고 80보다 작은 문자열이 주어진다. 문자열은 O와 X만으로 이루어져 있다.
###### -출력 
###### 각 테스트 케이스마다 점수를 출력한다.

```c++
#include <iostream>
#include <cmath>
#include <string>
using namespace std;

int main(){
    int N;
    cin >> N;
    int cnt = 0;
    int sum  = 0;
    int *arr = new int[N];
    string str;
    for(int i=0; i<N; i++){
        cin >> str;
        for(int j=0; j<str.length(); j++){
            if(str[j]=='O'){cnt++; sum = cnt+sum; }
            else{cnt = 0;}
        } 
        arr[i]=sum;
        sum = 0;
        cnt = 0;
    }
    for(int i=0; i<N ;i++){
        cout << arr[i]<<endl;
    }
    return 0;
}

```



##### 5.백준(11720) 숫자의 합
##### N개의 숫자가 공백 없이 쓰여있다. 이 숫자를 모두 합해서 출력하는 프로그램을 작성하시오.
##### -입력
##### 첫째 줄에 숫자의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄에 숫자 N개가 공백없이 주어진다.
##### -출력 
##### 입력으로 주어진 숫자 N개의 합을 출력한다.

```c++

#include<stdio.h>

int main(){
    int n, sum = 0;
    scanf("%d", &n);
    char arr[n];
    scanf("%s", &arr);
    for(int i = 0; i < n; i++){
        sum += arr[i] - '0';
    }
    printf("%d", sum);
}
```

##### 6.백준(3052) 나머지
##### 두 자연수 A와 B가 있을 때, A%B는 A를 B로 나눈 나머지 이다. 예를 들어, 7, 14, 27, 38을 3으로 나눈 나머지는 1, 2, 0, 2이다. 수 10개를 입력받은 뒤, 이를 42로 나눈 나머지를 구한다. 그 다음 서로 다른 값이 몇 개 있는지 출력하는 프로그램을 작성하시오.
##### -입력
##### 첫째 줄부터 열번째 줄 까지 숫자가 한 줄에 하나씩 주어진다. 이 숫자는 1,000보다 작거나 같고, 음이 아닌 정수이다.
##### -출력 
##### 첫째 줄에, 42로 나누었을 때, 서로 다른 나머지가 몇 개 있는지 출력한다.


```c++
#include <iostream>
#include <algorithm>
#include <vector>
#define N 10;

using namespace std;


int main(){

    int it = N;
    vector<int> arr;
    vector<int>::iterator iter = arr.begin();

    while(it!=0){
        int Number = 0;
        cin >> Number;
        arr.push_back(Number%42);
        it--;
    }
    sort(arr.begin(), arr.end()); //정렬
    arr.erase( unique(arr.begin(), arr.end() ), arr.end());// 중복값 제거 정렬 후 사용하여야 함
    cout << arr.size() << endl; // 벡터의 사이즈를 리턴

    

    return 0;
}
```

##### 7.백준(2675) 문자열 반복
##### 문자열 S를 입력받은 후에, 각 문자를 R번 반복해 새 문자열 P를 만든 후 출력하는 프로그램을 작성하시오. 즉, 첫 번째 문자를 R번 반복하고, 두 번째 문자를 R번 반복하는 식으로 P를 만들면 된다. S에는 QR Code "alphanumeric" 문자만 들어있다. QR Code "alphanumeric" 문자는 0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\$%*+-./: 이다.

##### -입력
##### 첫째 줄에 테스트 케이스의 개수 T(1 ≤ T ≤ 1,000)가 주어진다. 각 테스트 케이스는 반복 횟수 R(1 ≤ R ≤ 8), 문자열 S가 공백으로 구분되어 주어진다. S의 길이는 적어도 1이며, 20글자를 넘지 않는다. 
##### -출력 
##### 각 테스트 케이스에 대해 P를 출력한다.


```c++
#include <iostream>
#include <string>
#include <vector>
#include <string>

using namespace std;

int main(){
    
    int testCase =0 ;
    cin >> testCase;
    

    while(testCase--){
        vector<char>answer; // char 벡터 생성
        vector<char>::iterator iter = answer.begin();
        int it = 0;
        cin >> it; // 2
        string str ; 
        cin >> str; //ABC
        int len = str.length();
        //cout << " str is " << str << " "  << "len is " << len << endl;
        for(int i=0; i<len; i++){ //문자열의 길이만큼 반복
            for(int j=0; j<it; j++){ //주어진 횟수만큼 반복하여 추가
                answer.push_back(str[i]);
            }
        }
        for(iter=answer.begin(); iter!=answer.end(); iter++){
            cout << *iter ; //출력
        }
        cout << endl;      
    }
    return 0;
}


```